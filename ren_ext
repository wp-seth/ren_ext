#!/usr/bin/perl
# author: seth
# e-mail: for e-mail-address see http://www.wg-karlsruhe.de/seth/email_address.php
# description: renames files or directories using regexps
# thx to m. hoermann for utf8 support and some ideas of additional features
#
# tab-size: 2

use strict;
use warnings;
use Cwd;
use Getopt::Long qw(:config bundling);
use Pod::Usage;
#use Data::Dumper;

$main::VERSION = '1.26.20130817';

sub syntaxCheck{
	my %params = ( # default cli params
		'auto'        => 1,   # automatisms
		'capitalize'  => 0,   # capitalize names
		'directories' => 0,   # rename dirs
		'emodifier'   => 0,   # s///e
		'cmodifier'   => 0,   # y///c
		'dmodifier'   => 0,   # y///d
		'smodifier'   => 0,   # y///s
		'examples'    => 0,   # diplay examples and exit
		'files'       => 1,   # rename files
		'filesRE'     => '.', # RE for files to apply on
		'force'       => 0,   # force; grade of forcing renaming
		'global'      => 0,   # s///g
		'ignorecase'  => 0,   # s///i
		'mtime'       => 0,   # use modification time in replaceRE
		'path'        => 0,   # use full path instead of filenames only
		'predictive'  => 1,   # predictive; look-ahead, and break before start, if necessary
		'recursive'   => 0,   # search subdirs
		'test'        => 0,   # show result only (without renaming)
		'tr'          => 0,   # tr/// instead of s///
		'utf8'        => 0,   # interpret regexps and file names as unicode
		'verbose'     => 1,   # trace; grade of verbosity
		'version'     => 0,   # diplay version and exit
	);
	GetOptions(\%params,
		"auto!",
		"capitalize|c",
		"directories|d",
		"Directories|D" => sub { $params{'directories'} = 1; $params{'files'} = 0;},
		"filesRE|F=s",
		"force|f:i" => sub { $params{'force'} = not defined $_[1] ? 1 : $_[1];},
		"emodifier|e",
		"global|g",
		"ignorecase|i",
		"cmodifier|tr_c",
		"dmodifier|tr_d",
		"smodifier|tr_s",
		"examples",
		"mtime|m",
		"path|p",
		"predictive|p=i" => sub { pod2usage(-exitval=>2) if $_ !~ /^[01]$/;},
		"recursive|r",
		"test|t",
		"tr|y",
		"utf8|u",
		"editor=s" => sub { $params{'editors'} = $_[1].'|'.$params{'editors'};},
		"silent|quiet|q" => sub { $params{'verbose'} = 0;},
		"very-verbose" => sub { $params{'verbose'} = 2;},
		"verbose|v:+",
		"version|V" => sub { Getopt::Long::VersionMessage();}, # auto_version will not auto make use of 'V'
		"help|?|h" => sub { Getopt::Long::HelpMessage(-verbose=>99, -sections=>"NAME|SYNOPSIS");}, # auto_help will not auto make use of 'h'
		"man" => sub { pod2usage(-exitval=>0, -verbose=>2);},
		"examples" => sub { Getopt::Long::HelpMessage(-verbose=>99, -sections=>"EXAMPLES");},
	) or pod2usage(-exitval=>2);
	$params{'verbose'} = 1 unless exists $params{'verbose'};
	# check for unvalid combinations
	if(      $params{'tr'} 
				&& ($params{'emodifier'} || $params{'global'} || $params{'ignorecase'})
		 ||   !$params{'tr'}
				&& ($params{'cmodifier'} || $params{'dmodifier'} || $params{'smodifier'})
		){
		die " error: don't mix up the modifiers. use s///eig or tr///cds. see help: ren_ext --help\n";
	}
	# additional params
	my @additional_params = (2,2); # number of additional params (min, max);
	if(@ARGV<$additional_params[0] or ($additional_params[1]!=-1 and @ARGV>$additional_params[1])){
		if($additional_params[0]==$additional_params[1]){
			print "number of arguments must be exactly $additional_params[0], but is ".(0+@ARGV).".\n";
		}else{
			print "number of arguments must be at least $additional_params[0] and at most ".($additional_params[1] == -1 ? 'inf' : $additional_params[1]).", but is ".(0+@ARGV).".\n";
		}
		pod2usage(-exitval=>2);
	}
	$params{'findRE'} = $ARGV[0];
	$params{'replaceRE'} = $ARGV[1];
	return \%params;
}

sub capitalize{
	my $s = shift;
	$s = lc $s;
	$s=~s/\b(\w)/\u$1/g;     # capitalize all words
	$s=~s/\.(\w+)\z/.\l$1/g; # decapitalize file-extension
	return $s;
}

sub get_time_of_entry{
	my $file = shift;
	my $file_stat = (stat $file)[9];
	my @filetime  = localtime $file_stat;
	my $year  = sprintf "%04u", $filetime[5]+1900;
	my $month = sprintf "%02u", $filetime[4]+1;
	my $day   = sprintf "%02u", $filetime[3];
	return ($year, $month, $day);
}

sub decode_utf8{
	my $bytes = shift;
	utf8::decode($$bytes)
		or die 'invalid utf-8 encountered (try omitting option -u or --utf8 respectively)';
	return;
}

sub generate_searchreplace_string{
	my $params = shift;
	return ''.($$params{'tr'} ? 'tr' : 's').'/'.$$params{'findRE'}.'/'.$$params{'replaceRE'}.'/'.$$params{'emodifier'}.$$params{'ignorecase'}.$$params{'global'}.$$params{'cmodifier'}.$$params{'dmodifier'}.$$params{'smodifier'};
}

sub is_win{
	return $^O=~/win/i;
}

sub get_fullpath{
	my $filename = shift;
	my $fullpath = Cwd::abs_path($filename);
	$fullpath=~s/\//\\/g if(-d $filename && is_win());
	return $fullpath;
}

sub check_target_filename{
	my $filename = shift;
	if($filename=~/\\/ && is_win() || $filename=~/\//){
		my $output = shift;
		my $params = shift;
		print "error: operation not allowed!\n";
		print ' '.$output."\"\n";
		print ' slashes "/" (and in windows backslashes "\", too) are not allowed in target filenames'."\n";
		print ' files can be renamed only, they can\'t be moved to other directories with this tool.'."\n";
		print " findRE or replaceRE seem to be unvalid!.\n";
		if($$params{'path'} && $$params{'findRE'}!~/\^?\.\*/){
			print ' maybe you want to try'."\n";
			print '  findRE = .*'.$$params{'findRE'}."\n";
		}
		die 'program aborted.';
	}
	return;
}

sub rename_files_addon{
	my $working_dir = shift;
	my $overwrite   = shift;
	my $params      = shift;
	my $findRE      = $$params{'findRE'};
	my $filesRE     = $$params{'filesRE'};
	my $replaceRE   = $$params{'replaceRE'};
	my $ren_dirs    = $$params{'directories'};
	my $ren_files   = $$params{'files'};
	my $capitalize  = $$params{'capitalize'};
	my $mtime       = $$params{'mtime'};
	my $recursive   = $$params{'recursive'};
	my $test        = $$params{'test'};
	my $tr          = $$params{'tr'};
	my $force       = $$params{'force'};
	my $fullpath    = $$params{'path'};
	my $ignorecase  = $$params{'ignorecase'};
	my $prediction  = $$params{'prediction'};
	my $utf8        = $$params{'utf8'};
	my $verbose     = $$params{'verbose'};
	my $output;
	my $entry;
	my $entry_filename;
	my $exists;
	my @entries_to_rename;
	my $need_force;
	my @renamed_entries;
	my @dirs;
	my $searchreplace_string = generate_searchreplace_string($params);
	print "\n".'  '.$working_dir.'/'."\n" if $verbose>1;
	opendir(DIR, ".") or die $working_dir.": $!"; # read_dir and generate renaming_array
	while($entry_filename=readdir DIR){           # loop over directory entries
		next if($entry_filename eq '.' || $entry_filename eq '..');
		decode_utf8(\$entry_filename) if $utf8;
		push(@dirs, $entry_filename) if -d $entry_filename;
		if($fullpath){
			$entry = get_fullpath($entry_filename);
			decode_utf8(\$entry) if $utf8; 
		}else{
			$entry = $entry_filename;
		}
		if((($ren_dirs && -d $entry_filename) || ($ren_files && not -d $entry_filename)) 
		  && $entry=~/$filesRE/ 
		  &&( $tr
		    || !$tr
		    &&( ($ignorecase eq ''  && $entry=~/$findRE/) 
		      ||($ignorecase eq 'i' && $entry=~/$findRE/i)
			    )
			  )
			){                                        # if entry should be renamed
			my ($y, $mon, $d) = get_time_of_entry($entry_filename) if $mtime==1;
			print "\n".'  '.$working_dir.'/'."\n" if $verbose==1 && @entries_to_rename==0;
			$output = 'rename: "'.$entry_filename;
			print "'$entry'=~$searchreplace_string\n" if $verbose>2;
			push(@entries_to_rename, $entry_filename);
			eval('$entry=~'.$searchreplace_string);   # generate new file name
			#$entry = substr $entry, length($`) if($fullpath && (!is_win() && -1<index($`, '/') || is_win() && -1<index($`, '\\')));
			$entry = capitalize($entry) if $capitalize;
			$output .= '" ==> "'.$entry;
			check_target_filename($entry, $output, $params);
			$need_force = 0;
			# check for collisions
			if((!is_win() && grep {$_ eq $entry} @renamed_entries)
				|| (is_win() && grep {lc $_ eq lc($entry)} @renamed_entries)
				){                                      # if another file was already renamed to the same name
				++$$overwrite{'newfiles'};
				$output .= ' (another file '.(($force>1)? 'will' : 'would').' be renamed to this name already!)';
				$need_force = 2;
			}
			if(-e $entry){                            # target file exists already
				if($entry eq $entries_to_rename[-1]){   # old_name == new_name
					$output .= ' (name unchanged)';
				}elsif(is_win() && lc $entry eq lc $entries_to_rename[-1]){
					$output .= ' (changing case only)';   # case-change (win-only)
				}else{
					++$$overwrite{'existingfiles'};       # overwrite existing file?
					$output .= ' (existing already! '.(($force>0)? 'will' : 'won\'t').' be overwritten.)';
					$need_force = 1 if $need_force<1;
				}
			}
			unless(-e $entry && $entry eq $entries_to_rename[-1] && $tr){
				print $output."\"\n" if $verbose>0 && ($prediction==0 || $need_force>0) || $verbose>1;
			}
			if($force>=$need_force){
				push @renamed_entries, $entry;
			}else{
				pop @entries_to_rename;
			}
		}else{
			print 'skip: '.$entry."\n" if $verbose>1;
		}
	}
	closedir DIR;
	@dirs = sort @dirs;
	if($recursive==1){ # first search subdirectories
		for(@dirs){
			chdir $_;
			rename_files_addon($working_dir.'/'.$_, $overwrite, $params);
			chdir '..';
		}
	}
	if(!$test && !$prediction){ # after searching subdirectories begin renaming
		for(my $i=0; $i<@entries_to_rename; ++$i){
			rename $entries_to_rename[$i], $renamed_entries[$i];
		}
	}
	return;
}

sub rename_files_using_regexps{
	my %params = syntaxCheck(@_);
	# postprocess params
	if($params{'auto'}){
		# escape unescaped slashes
		$params{$_}=~s/(?<!\\)((?:\\\\)*)\//$1\\\//g for('findRE', 'replaceRE', 'filesRE');
		# add prefix and suffix to findRE for intuitive fullpath searching
		$params{findRE} = '.*?'.$params{findRE}.'(?=[^\/]*\z)' if $params{'path'};
	}
	if($params{'utf8'}){
		# enable unicode for both regular expressions ...
		decode_utf8(\$params{$_})	for('findRE', 'replaceRE', 'filesRE');
		# ... and for the screen output
		binmode(STDOUT, ':utf8');
		binmode(STDERR, ':utf8');
	}
	# bool2modifier 
	$params{'cmodifier'}  = ($params{'cmodifier'}) ? 'c' : '';
	$params{'dmodifier'}  = ($params{'dmodifier'}) ? 'd' : '';
	$params{'emodifier'}  = ($params{'emodifier'}) ? 'e' : '';
	$params{'smodifier'}  = ($params{'smodifier'}) ? 's' : '';
	$params{'global'}     = ($params{'global'}) ? 'g' : '';
	$params{'ignorecase'} = ($params{'ignorecase'}) ? 'i' : '';

	my $working_dir = cwd;
	decode_utf8(\$working_dir) if $params{'utf8'};
	my %overwrite; # counting of overwritten files
	$overwrite{'existingfiles'} = 0;
	$overwrite{'newfiles'} = 0;
	print ' using '.generate_searchreplace_string(\%params)."\n" if $params{'verbose'}>0;
	if($params{'test'}==0 && $params{'predictive'}==1){        # if not just testing, predict collisions
		print 'predicting changes/collisions...'."\n" if $params{'verbose'}>0;
		$params{'prediction'} = 1;
		rename_files_addon($working_dir, \%overwrite, \%params);
		print 'number of collisions: '.($overwrite{'existingfiles'}+$overwrite{'newfiles'})."\n" if $params{'verbose'}>1;
	}
	if($params{'force'}==0 and $overwrite{'existingfiles'}+$overwrite{'newfiles'}==0 or
		$params{'force'}==1 and $overwrite{'newfiles'}==0 or
		$params{'force'}==2){ # call renaming-routine
		print $params{'test'} ? "\ntesting...\n": "\nrenaming...\n" if $params{'verbose'}>0;
		$params{'prediction'} = 0;
		rename_files_addon($working_dir, \%overwrite, \%params);
	}elsif($params{'verbose'}>0){
		print $overwrite{'existingfiles'}.' existing and '.$overwrite{'newfiles'}.' new files would be overwritten.'."\n";
	}
	chdir $working_dir;
	return;
}

rename_files_using_regexps(@ARGV);

__END__

=head1 NAME

ren_ext ("rename extended") renames (recursively) files and directories using 
regexps.

=head1 DESCRIPTION

this program lets you renames files or directories by using regular expressions. 

it includes a check, whether a target filename already exists or whether several 
target filenames are same, and prints a warning in such cases.

=head1 SYNOPSIS

ren_ext findRE replaceRE [options]
or
ren_ext [options] findRE replaceRE

  findRE                 files to rename given by a regexp
  replaceRE              how to rename, i.e., s/findRE/replaceRE/ in perl syntax
  -c, --capitalize       Capitalize Every Word
  -d, --directories      rename files and directories (default: files only)
  -D, --Directories      rename directories only (default: files only)
  -m, --mtime            use $y, $mon, $d in replaceRE to insert modification
                          time
  -p, --path             while searching use full paths of files in findRE
                          (default: base filenames only)
                          for the sake of intuition this options automatically 
                          sets .*? as prefix and (?=[^\/]*\z) as suffix of
                          findRE
      --no-auto          disables automatisms, i.e., 
                          1. automatically generated prefixes and suffixes
                             in findRE, when using --path, and
                          2. escaping of unescaped slashes in findRE, filesRE,
                             and replaceRE by backslashes
  -r, --recursive        for searching subdirectories recursively
  -t, --test             don't change anything, just print possible changes to
                          screen
  -u, --utf8             enable unicode support for input, output, and renaming
  -y  --tr               use tr/findRE/replaceRE/ instead of s/findRE/replaceRE/
  -F  --filesRE=s        restrict replacements to files given by regexp string s 
                          (default s=".", i.e., all files)

force overwriting:

  -p, --predictive=x     first look for possible overwriting or not...
                          x=0: rename, but skip files, which would be
                               overwritten, but shouldn't (depends on --force).
                          x=1: don't even start renaming, if files would be 
                               overwritten, that shouldn't (depends on --force).
                               (default)
  -f, --force            same as --force=1
  -f, --force=x          grade of forcing renaming
                          x=0: don't overwrite any files (default)
                          x=1: overwrite existing (but not already renamed)
                               files
                          x=2: overwrite even renamed files

regexp-modifiers:

  -e, --emodifier        set e-modifier in RE, i.e., s/findRE/replaceRE/e
                          (maybe you should consider using --no-auto if you
                           use slashes in replaceRE)
                          (don't combine this with parameter --tr)
  -g, --global           set g-modifier, i.e., rename as many times as possible,
                          i.e., s/findRE/replaceRE/g
                          (don't combine this with parameter --tr)
  -i, --ignorecase       set i-modifier, i.e., ignore case in findRE, i.e., 
                          s/findRE/replaceRE/i
                          (don't combine this with parameter --tr)
      --tr_c             use c-modifier (only if --tr is used), i.e., 
                         complement findRE.
      --tr_d             use d-modifier (only if --tr is used), i.e.,
                          delete found but unreplaced characters.
      --tr_s             use s-modifier (only if --tr is used), i.e.,
                          squash duplicate replaced characters.
meta:

      --examples         show some examples of using this tool
  -V, --version          display version and exit.
  -h, --help             display brief help
      --man              display long help (man page)
  -q, --silent           same as --verbose=0
  -v, --verbose          same as --verbose=1 (default)
  -vv,--very-verbose     same as --verbose=2
  -v, --verbose=x        grade of verbosity
                          x=0: no output
                          x=1: default output
                          x=2: much output

some examples:

  ren_ext ASD asd
    replaces _first_ occurrence of 'ASD' by 'asd' in all files, e.g.
    fooASDASD.txt -> fooasdASD (use -g for replacing all occurrences)
  
  ren_ext --examples
    shows more examples

=head1 EXAMPLES

ren_ext
  displays help

ren_ext 'ASD' 'asd'
  replaces _first_ occurrence of "ASD" by "asd" in all files, e.g.
  fooASDASD.txt -> fooasdASD

ren_ext 'ASD' 'asd' -g
  replaces all occurrence of 'ASD' by 'asd' in all files, e.g.
  fooASDASD.txt -> fooasdasd

ren_ext '(.)' '\u$1'
  sets _first_ character to upper case (use -g for all)

ren_ext '.*cd(\d+)/([^/]+)$' '$1$2' --path -r
  uses full path, i.e., renames ...cd01/title.ogg to
  ...cd01/01title.ogg and so on (no files will be moved to another
  directory)

ren_ext '(/d)(/d)' '$2$1' -gr
  exchanges digits of numbers in all filenames recursively

ren_ext '(error_log\.)\d+(\.gz)' '$1$y-$mon-$d$2' --mtime
  e.g. errog_log.10.gz -> error_log.2007-07-07.gz

ren_ext -r -- -foo -bar
  this will replace '-foo' by '-bar' recursively

ren_ext 'foo(\d\d)' '"bar".($1+42)' -ert
  prints the result of replacing e.g. 'foo10' by 'bar52' recursively,
  but doesn't really change filenames

ren_ext '(\p{Cyrillic}+)' '\U$1' -drug
  uppercase all cyrillic letters of files and directories in this 
  directory and all subdirectories

ren_ext 'xy' 'yx' --tr -F 'foo_x=\d+_y=\d+'
  use tr/xy/yx/ on all files that match /foo_x=\d+_y=\d+/, i.e., 
  switch the letters 'x' and 'y' in all of those files

note that in windows you have to use double quotes instead of single quotes.

=head1 OPTIONS

=over 8

=item B<--auto>, B<--no-auto>

B<--auto> enables automatisms, i.e., 

1. automatically generated prefixes and suffixes in B<findRE>, when using B<--path>, and

2. escaping of unescaped slashes in B<findRE>, B<--filesRE>, and B<replaceRE> by backslashes.

B<--no-auto> disables those automatisms.

=item B<--capitalize>, B<-c>

Capitalize Every Word In Filename

=item B<--directories>, B<-d>

rename files and directories (default: files only)

=item B<--Directories>, B<-D>

rename directories only (default: files only)

=item B<--filesRE>=I<string>, B<-F> I<string>

restrict replacements to files given by regexp I<string> (default ".", i.e., all files)

=item B<--mtime>, B<-m>

use $y, $mon, $d in B<replaceRE> to insert modification time

=item B<--path>, B<-p>

while searching use full paths of files/directories in B<findRE> (default: base 
filenames only).

for the sake of intuition this options automatically sets .*? as prefix and 
(?=[^\/]*\z) as suffix of B<findRE>.

=item B<--recursive>, B<-r>

search subdirectories recursively

=item B<--test>, B<-t>

don't change anything, just print possible changes to screen

=item B<--tr>, B<-y>

use charwise replacement tr/findRE/replaceRE/ instead of s/findRE/replaceRE/.

see perl manual for more information.

=over 8

=item B<--tr_c>, B<--cmodifier>

use c-modifier (only if B<--tr> is used), i.e., complement B<findRE>.

=item B<--tr_d>, B<--dmodifier>

use d-modifier (only if B<--tr> is used), i.e., delete found but unreplaced characters.

=item B<--tr_s>, B<--smodifier>

use s-modifier (only if B<--tr> is used), i.e., squash duplicate replaced characters.

=back

=item B<--utf8>, B<-u>

enable unicode support for input, output, and renaming

=item B<--predictive>=I<bool>, B<-p> I<bool>

first look for possible overwriting or not...

I<bool> = 0: rename, but skip files, which would be overwritten, but shouldn't (depends on B<--force>).

I<bool> = 1 (default): don't even start renaming, if files would be overwritten, that shouldn't (depends on B<--force>).

=item B<--force>, B<-f>

same as B<--force>=I<1>

=item B<--force>=I<int>, B<-f> I<int>

grade of forcing renaming

I<int> = 0 (default): don't overwrite any files

I<int> = 1: overwrite existing (but not already renamed) files

I<int> = 2: overwrite even renamed files

=item B<--emodifier>, B<-e>

set e-modifier in RE, i.e., 

 s/findRE/replaceRE/e

maybe you should consider using B<--no-auto> if you use slashes in B<replaceRE>.

don't combine this with parameter B<--tr>.

=item B<--global>, B<-g>

set g-modifier, i.e., rename as many times as possible, i.e., 

 s/findRE/replaceRE/g

don't combine this with parameter B<--tr>.

=item B<--ignorecase>, B<-i>

set i-modifier, i.e., ignore case in B<findRE>, i.e., 

 s/findRE/replaceRE/i
 
don't combine this with parameter B<--tr>.

=item B<--version>, B<-V>

prints version and exits.

=item B<--help>, B<-h>, B<-?>

prints a brief help message and exits.

=item B<--man>

prints the manual page and exits.

=item B<--verbose>=I<number>, B<-v> I<number>

set grade of verbosity to I<number>. if I<number>==0 then no output
will be given, except hard errors. the higher I<number> is, the more 
output will be printed. default: I<number> = 1.

=item B<--silent, --quiet, -q>

same as B<--verbose=0>.

=item B<--very-verbose, -vv>

same as B<--verbose=2>. you may use B<-vvv> for B<--verbose=3> a.s.o.

=item B<--verbose, -v>

same as B<--verbose=1>.

=back

=head1 LICENCE

this program is distributed in the hope that it will be useful,
but without any warranty; without even the implied warranty of
merchantability or fitness for a particular purpose.

originally written by seth (for e-mail-address see
<http://www.wg-karlsruhe.de/seth/email_address.php>).

=cut
