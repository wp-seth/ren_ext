#!/usr/bin/perl
# author:  seth
# contact: see https://github.com/wp-seth/ren_ext
# description: renames files or directories using regexps
# thx to m. hoermann for utf8 support and some ideas of additional features

use strict;
use warnings;
use Cwd;
use Data::Dumper;
use Getopt::Long qw(:config bundling);
use Pod::Usage;
#use utf8;

$main::VERSION = '1.31.1'; # 20180429
#binmode STDOUT, ":utf8";

# functions
# =========
# sub syntaxCheck
#		check input of user
#
# sub capitalize
#		capitalize filename but de-capitalize file-extension
#
# sub get_time_of_file
#		get date of last modification of a file
#
# sub decode_utf8
#		wrapper for utf8::decode
#
# sub generate_searchreplace_string
#		generate perl's search-replace-string by user input
#
# sub is_win
#		check whether current os is microsoft windows
#
# sub get_fullpath
#		get absolute path from filename
#
# sub check_target_filename
#		check whether target filename contains slashes or backslashes
# sub rename_files_per_re

sub syntaxCheck{
	my %params = ( # default cli params
		'auto'        => 1,   # automatisms
		'capitalize'  => 0,   # capitalize names
		'directories' => 0,   # rename dirs
		'emodifier'   => 0,   # s///e
		'cmodifier'   => 0,   # y///c
		'dmodifier'   => 0,   # y///d
		'smodifier'   => 0,   # y///s
		'examples'    => 0,   # diplay examples and exit
		'files'       => 1,   # rename files
		'filesRE'     => '.', # RE for files to apply on
		'force'       => 0,   # force; grade of forcing renaming
		'global'      => 0,   # s///g
		'ignorecase'  => 0,   # s///i
		'mtime'       => 0,   # use modification time in replaceRE
		'path'        => 0,   # use full path instead of filenames only
		'predictive'  => 1,   # predictive; look-ahead, and break before start, if necessary
		'recursive'   => 0,   # search subdirs
		'test'        => 0,   # show result only (without renaming)
		'tr'          => 0,   # tr/// instead of s///
		'utf8'        => 0,   # interpret regexps and file names as unicode
		'verbose'     => 1,   # trace; grade of verbosity
		'version'     => 0,   # diplay version and exit
	);
	GetOptions(\%params,
		'auto!',
		'capitalize|c',
		'directories|d',
		'Directories|D' => sub { $params{'directories'} = 1; $params{'files'} = 0;},
		'filesRE|F=s',
		'force|f:i' => sub { $params{'force'} = not defined $_[1] ? 1 : $_[1];},
		'emodifier|e',
		'global|gmodifier|g',
		'ignorecase|imodifier|i',
		'cmodifier|tr_c',
		'dmodifier|tr_d',
		'smodifier|tr_s',
		'examples',
		'mtime|m',
		'path',
		'predictive|p=i' => sub { 
			pod2usage(-exitval=>2) if $_[1] !~ /^[01]$/; 
			$params{'predictive'} = $_[1];
		},
		'recursive|r',
		'test|t',
		'tr|y',
		'utf8|u',
		'silent|quiet|q' => sub { $params{'verbose'} = 0;},
		'very-verbose' => sub { $params{'verbose'} = 2;},
		'verbose|v:+',
		# auto_version will not auto make use of 'V'
		'version|V' => sub { Getopt::Long::VersionMessage();},
		# auto_help will not auto make use of 'h'
		'help|?|h' => sub { Getopt::Long::HelpMessage(
				-verbose  => 99,
				-sections => 'NAME|SYNOPSIS'
			);
		},
		'man' => sub { pod2usage(-exitval => 0, -verbose => 2);},
		'examples' => sub { Getopt::Long::HelpMessage(
				-verbose => 99, -sections => 'EXAMPLES'
			);
		},
	) or pod2usage(-exitval => 2);
	$params{'verbose'} = 1 unless exists $params{'verbose'};
	# check for unvalid combinations
	if(      $params{'tr'} 
				&& ($params{'emodifier'} || $params{'global'} || $params{'ignorecase'})
		 ||   !$params{'tr'}
				&& ($params{'cmodifier'} || $params{'dmodifier'} || $params{'smodifier'})
		){
		die " error: don't mix up the modifiers. use s///eig or tr///cds. see help: ren_ext --help\n";
	}
	# additional params
	my @additional_params = (2, 2); # number of additional params (min, max);
	if(@ARGV < $additional_params[0] or
		($additional_params[1] != -1 and @ARGV > $additional_params[1])
	){
		if($additional_params[0] == $additional_params[1]){
			print "error: number of arguments must be exactly $additional_params[0]," . 
				' but is ' . (0 + @ARGV) . ".\n";
		}else{
			print "error: number of arguments must be at least $additional_params[0]" .
				' and at most ' .
				($additional_params[1] == -1 ? 'inf' : $additional_params[1]) .
				", but is " . (0 + @ARGV) . ".\n";
		}
		pod2usage(-exitval => 2);
	}
	$params{'findRE'} = $ARGV[0];
	$params{'replaceRE'} = $ARGV[1];
	return \%params;
}

sub capitalize{
	my $s = shift;
	$s = lc $s;
	$s =~ s/\b(\w)/\u$1/g;     # capitalize all words
	$s =~ s/\.(\w+)\z/.\l$1/g; # decapitalize file-extension
	return $s;
}

sub get_time_of_file{
	my $file = shift;
	my $file_stat = (stat $file)[9];
	my @filetime  = localtime $file_stat;
	my $year  = sprintf "%04u", $filetime[5]+1900;
	my $month = sprintf "%02u", $filetime[4]+1;
	my $day   = sprintf "%02u", $filetime[3];
	my $hours = sprintf "%02u", $filetime[2];
	my $min   = sprintf "%02u", $filetime[1];
	my $sec   = sprintf "%02u", $filetime[0];
	return ($year, $month, $day, $hours, $min, $sec);
}

sub decode_utf8{
	my $bytes = shift;
	utf8::decode($$bytes)
		or die 'invalid utf-8 encountered (try omitting option -u or --utf8 respectively)';
	return 1;
}

sub generate_searchreplace_string{
	my $params = shift;
	return ''.($params->{'tr'} ? 'tr' : 's').'/'.$params->{'findRE'}.'/'.
		$params->{'replaceRE'}.'/'.
		$params->{'emodifier'}.
		$params->{'global'}.
		$params->{'cmodifier'}.
		$params->{'dmodifier'}.
		$params->{'smodifier'};
}

sub is_win{
	return $^O =~ /win/i;
}

sub get_fullpath{
	my $filename = shift;
	my $fullpath = Cwd::abs_path($filename);
	$fullpath =~ s/\//\\/g if -d $filename and is_win();
	return $fullpath;
}

sub check_target_filename{
	my $filename = shift;
	if($filename=~/\\/ and is_win() or $filename=~/\//){
		my $output = shift;
		my $params = shift;
		print "error: operation not allowed!\n";
		print ' '.$output."\"\n";
		print ' slashes "/" (and in microsoft windows backslashes "\", too) are not allowed in target filenames'."\n";
		print ' files can be renamed only, they can\'t be moved to other directories with this tool.'."\n";
		print " findRE or replaceRE seem to be unvalid!.\n";
		if($params->{'path'} and $params->{'findRE'}!~/\^?\.\*/){
			print ' maybe you want to try'."\n";
			print '  findRE = .*'.$params->{'findRE'}."\n";
		}
		die 'program aborted.';
	}
	return;
}

sub rename_files_per_re{
	my $working_dir = shift;
	my $overwrite   = shift;
	my $params      = shift;
	my $findRE      = $params->{'findRE'};
	my $filesRE     = $params->{'filesRE'};
	my $replaceRE   = $params->{'replaceRE'};
	my $ren_dirs    = $params->{'directories'};
	my $ren_files   = $params->{'files'};
	my $capitalize  = $params->{'capitalize'};
	my $mtime       = $params->{'mtime'};
	my $recursive   = $params->{'recursive'};
	my $test        = $params->{'test'};
	my $tr          = $params->{'tr'};
	my $force       = $params->{'force'};
	my $fullpath    = $params->{'path'};
	my $prediction  = $params->{'prediction'};
	my $utf8        = $params->{'utf8'};
	my $verbose     = $params->{'verbose'};
	my $output;
	my $entry;
	my $entry_filename;
	my $exists;
	my @entries_to_rename;
	my $need_force;
	my @renamed_entries;
	my @dirs;
	my $searchreplace_string = generate_searchreplace_string($params);
	print "\n" . '  ' . $working_dir . '/' . "\n" if $verbose > 1;
	opendir(DIR, '.') or die $working_dir.": $!"; # read_dir and generate renaming_array
	while($entry_filename = readdir DIR){         # loop over directory entries
		next if $entry_filename eq '.' or $entry_filename eq '..';
		decode_utf8(\$entry_filename) if $utf8;
		push(@dirs, $entry_filename) if -d $entry_filename;
		if($fullpath){
			$entry = get_fullpath($entry_filename);
			decode_utf8(\$entry) if $utf8; 
		}else{
			$entry = $entry_filename;
		}
		if(($ren_dirs and -d $entry_filename or $ren_files and not -d $entry_filename) 
			and $entry =~ /$filesRE/ 
			and ($tr or !$tr and $entry =~ /$findRE/)
		){ # if entry should be renamed
			my ($y, $mon, $d, $h, $min, $s) = get_time_of_file($entry_filename) if $mtime == 1;
			print "\n".'  '.$working_dir.'/'."\n" if $verbose==1 and @entries_to_rename == 0;
			$output = 'rename: "'.$entry_filename;
			print "'$entry' =~ $searchreplace_string\n" if $verbose > 2;
			push(@entries_to_rename, $entry_filename);
			eval('$entry =~ ' . $searchreplace_string);   # generate new file name
			#$entry = substr $entry, length($`) if($fullpath && (!is_win() && -1<index($`, '/') || is_win() && -1<index($`, '\\')));
			$entry = capitalize($entry) if $capitalize;
			$output .= '" ==> "'.$entry;
			check_target_filename($entry, $output, $params);
			$need_force = 0;
			# check for collisions
			if(   (!is_win() and grep {   $_ eq    $entry } @renamed_entries)
					or (is_win() and grep {lc $_ eq lc($entry)} @renamed_entries)
				){                                      # if another file was already renamed to the same name
				++$overwrite->{'newfiles'};
				$output .= ' (another file '.(($force>1)? 'will' : 'would').' be renamed to this name already!)';
				$need_force = 2;
			}
			if(-e $entry){                            # target file exists already
				if($entry eq $entries_to_rename[-1]){   # old_name == new_name
					$output .= ' (name unchanged)';
				}elsif(is_win() && lc $entry eq lc $entries_to_rename[-1]){
					$output .= ' (changing case only)';   # case-change (win-only)
				}else{
					++$overwrite->{'existingfiles'};       # overwrite existing file?
					$output .= ' (existing already! '.(($force>0)? 'will' : 'won\'t').' be overwritten.)';
					$need_force = 1 if $need_force<1;
				}
			}
			unless(-e $entry and $entry eq $entries_to_rename[-1] and $tr){
				print $output."\"\n" if $verbose>0 and ($prediction==0 or $need_force>0) or $verbose>1;
			}
			if($force>=$need_force){
				push @renamed_entries, $entry;
			}else{
				pop @entries_to_rename;
			}
		}else{
			print 'skip: '.$entry."\n" if $verbose>1;
		}
	}
	closedir DIR;
	@dirs = sort @dirs;
	if($recursive==1){ # first search subdirectories
		for(@dirs){
			chdir $_;
			rename_files_per_re($working_dir.'/'.$_, $overwrite, $params);
			chdir '..';
		}
	}
	if(!$test and !$prediction){ # after searching subdirectories begin renaming
		for(my $i=0; $i<@entries_to_rename; ++$i){
			rename $entries_to_rename[$i], $renamed_entries[$i];
		}
	}
	return;
}

# main
my $params = syntaxCheck(@ARGV);
# postprocess params
if($params->{'auto'}){
	# escape unescaped slashes
	$params->{$_}=~s/(?<!\\)((?:\\\\)*)\//$1\\\//g for('findRE', 'replaceRE', 'filesRE');
	# add prefix and suffix to findRE for intuitive fullpath searching
	$params->{'findRE'} = '.*?'.$params->{'findRE'}.'(?=[^\/]*\z)' if $params->{'path'};
}

# prepare regexp concerning case-(in)sensitivity
if(not $params->{'tr'}){
	$params->{'findRE'} = ($params->{'ignorecase'}) ? 
		qr/$params->{'findRE'}/i : qr/$params->{'findRE'}/;
}

if($params->{'utf8'}){
	# enable unicode for both regular expressions ...
	decode_utf8(\$params->{$_})	for('findRE', 'replaceRE', 'filesRE');
	# ... and for the screen output
	binmode(STDOUT, ':utf8');
	binmode(STDERR, ':utf8');
}
# bool2modifier 
$params->{'cmodifier'}  = ($params->{'cmodifier'}) ? 'c' : '';
$params->{'dmodifier'}  = ($params->{'dmodifier'}) ? 'd' : '';
$params->{'emodifier'}  = ($params->{'emodifier'}) ? 'e' : '';
$params->{'smodifier'}  = ($params->{'smodifier'}) ? 's' : '';
$params->{'global'}     = ($params->{'global'}) ? 'g' : '';

my $working_dir = cwd;
decode_utf8(\$working_dir) if $params->{'utf8'};
my %overwrite; # counting of overwritten files
$overwrite{'existingfiles'} = 0;
$overwrite{'newfiles'} = 0;
print ' using '.generate_searchreplace_string($params)."\n" if $params->{'verbose'}>0;
if($params->{'test'}==0 and $params->{'predictive'}==1){        # if not just testing, predict collisions
	print 'predicting changes/collisions...'."\n" if $params->{'verbose'}>0;
	$params->{'prediction'} = 1;
	rename_files_per_re($working_dir, \%overwrite, $params);
	if($params->{'verbose'}>1){
		print 'number of collisions: '.
			($overwrite{'existingfiles'} + $overwrite{'newfiles'})."\n";
	}
}
if($params->{'force'}==0 and $overwrite{'existingfiles'}+$overwrite{'newfiles'}==0 or
	$params->{'force'}==1 and $overwrite{'newfiles'}==0 or
	$params->{'force'}==2){ # call renaming-routine
	print $params->{'test'} ? "\ntesting...\n": "\nrenaming...\n" if $params->{'verbose'}>0;
	$params->{'prediction'} = 0;
	rename_files_per_re($working_dir, \%overwrite, $params);
}elsif($params->{'verbose'}>0){
	print $overwrite{'existingfiles'}.' existing and '.$overwrite{'newfiles'}.' new files would be overwritten.'."\n";
}
chdir $working_dir;

__END__

=head1 NAME

ren_ext ("rename extended") renames (recursively) files and directories using 
regexps.

=head1 DESCRIPTION

this program lets you rename files or directories by using regular expressions. 

it includes a check, whether a target filename already exists or whether several 
target filenames are same, and prints a warning in such cases.

=head1 SYNOPSIS

ren_ext findRE replaceRE [options]
or
ren_ext [options] findRE replaceRE

  findRE                 files to rename given by a regexp
  replaceRE              how to rename, i.e., s/findRE/replaceRE/ in perl syntax
  -c, --capitalize       Capitalize Every Word
  -d, --directories      rename files and directories (default: files only)
  -D, --Directories      rename directories only (default: files only)
  -m, --mtime            use $y, $mon, $d, $h, $min, $s in replaceRE to insert
                          modification time
      --path             while searching use full paths of files in findRE
                          (default: base filenames only)
                          for the sake of intuition this options automatically 
                          sets .*? as prefix and (?=[^\/]*\z) as suffix of
                          findRE
      --no-auto          disables automatisms, i.e., 
                          1. automatically generated prefixes and suffixes
                             in findRE, when using --path, and
                          2. escaping of unescaped slashes in findRE, filesRE,
                             and replaceRE by backslashes
  -r, --recursive        for searching subdirectories recursively
  -t, --test             don't change anything, just print possible changes to
                          screen
  -u, --utf8             enable unicode support for input, output, and renaming
  -y  --tr               use tr/findRE/replaceRE/ instead of s/findRE/replaceRE/
  -F  --filesRE=s        restrict replacements to files given by regexp string s 
                          (default s=".", i.e., all files)

force overwriting:

  -p, --predictive=x     (don't) look for possible overwriting first ...
                          x=0: start renaming, but skip those files that would 
                               overwrite other files that shouldn't be 
                               overwritten (depends on --force).
                          x=1: don't even start renaming of any file, if one
                               file would be overwritten that shouldn't be 
                               overwritten (depends on --force). (default)
  -f, --force            same as --force=1
  -f, --force=x          grade of forcing renaming
                          x=0: don't overwrite any files (default)
                          x=1: overwrite existing (but not already renamed)
                               files
                          x=2: overwrite even renamed files

regexp-modifiers:

  -e, --emodifier        set e-modifier in RE, i.e., s/findRE/replaceRE/e
                          (maybe you should consider using --no-auto if you
                           use slashes in replaceRE)
                          (don't combine this with parameter --tr)
  -g, --global           set g-modifier, i.e., rename as many times as possible,
                          i.e., s/findRE/replaceRE/g
                          (don't combine this with parameter --tr)
  -i, --ignorecase       set i-modifier, i.e., ignore case in findRE, i.e., 
                          s/findRE/replaceRE/i
                          (don't combine this with parameter --tr)
      --tr_c             use c-modifier (only if --tr is used), i.e., 
                         complement findRE.
      --tr_d             use d-modifier (only if --tr is used), i.e.,
                          delete found but unreplaced characters.
      --tr_s             use s-modifier (only if --tr is used), i.e.,
                          squash duplicate replaced characters.
meta:

      --examples         show some examples of using this tool
  -V, --version          display version and exit.
  -h, --help             display brief help
      --man              display long help (man page)
  -q, --silent           same as --verbose=0
  -v, --verbose          same as --verbose=2
  -vv,--very-verbose     same as --verbose=3
  -v, --verbose=x        grade of verbosity
                          x=0: no output
                          x=1: default output
                          x=2: much output

some examples:

  ren_ext ASD asd
    replaces _first_ occurrence of 'ASD' by 'asd' in all files, e.g.
    fooASDASD.txt -> fooasdASD.txt (use -g for replacing all occurrences)
  
  ren_ext --examples
    shows more examples

=head1 EXAMPLES

ren_ext

  displays help

ren_ext 'ASD' 'sdf'

  replaces _first_ occurrence of "ASD" by "sdf" in all files, e.g.
  fooASDASD.txt -> foosdfASD.txt

ren_ext 'ASD' 'sdf' -g

  replaces all occurrence of 'ASD' by 'sdf' in all files, e.g.
  fooASDASD.txt -> foosdfsdf.txt

ren_ext '(.)' '\u$1'

  sets _first_ character to upper case.

ren_ext '(.)' '\l$1' -g

  sets all characters to lower case.

ren_ext '[A-Z]' '[a-z]' -y

  sets all latin characters to lower case.

ren_ext '(\p{Cyrillic}+)' '\U$1' -drug

  uppercase all cyrillic letters of files and directories in this 
  directory and all subdirectories.

ren_ext '.*cd(\d+)/([^/]+)$' '$1$2' --path -r

  uses full path, i.e., renames ...cd01/title.ogg to
  ...cd01/01title.ogg and so on (no files will be moved to another
  directory).

ren_ext '(/d)(/d)' '$2$1' -gr

  exchanges digits of numbers in all filenames recursively.

ren_ext '(error_log\.)\d+(\.gz)' '$1$y-$mon-$d$2' --mtime

  e.g. errog_log.10.gz -> error_log.2007-07-07.gz

ren_ext -r -- -foo -bar

  this will replace '-foo' by '-bar' recursively.

ren_ext 'foo(\d\d)' '"bar".($1+42)' -ert

  prints the result of replacing e.g. 'foo10' by 'bar52' recursively,
  but doesn't really change filenames.

ren_ext 'xy' 'yx' --tr -F 'foo_x=\d+_y=\d+'

  use tr/xy/yx/ on all files that match /foo_x=\d+_y=\d+/, i.e., 
  switch the letters 'x' and 'y' in all of those files.

ren_ext -e 'segment\K([0-9]+)(?=_)' 'sprintf("%03d", $1)'

  add leading zeros on numbers with <3 digits, e.g., 
  change parts like 'segment{number}_' to 'segment{number_with_leading_zero}_'.

note that in microsoft windows you have to use double quotes instead of single 
quotes.

=head1 OPTIONS

=over 8

=item B<--auto>, B<--no-auto>

B<--auto> enables automatisms, i.e., 

1. automatically generated prefixes and suffixes in B<findRE>, when using B<--path>, and

2. escaping of unescaped slashes in B<findRE>, B<--filesRE>, and B<replaceRE> by backslashes.

B<--no-auto> disables those automatisms.

=item B<--capitalize>, B<-c>

Capitalize Every Word In Filename

=item B<--directories>, B<-d>

rename files and directories (default: files only)

=item B<--Directories>, B<-D>

rename directories only (default: files only)

=item B<--filesRE>=I<string>, B<-F> I<string>

restrict replacements to files given by regexp I<string> (default ".", i.e., all files)

=item B<--mtime>, B<-m>

use $y, $mon, $d, $h, $min, $s in B<replaceRE> to insert file modification time

=item B<--path>

while searching use full paths of files/directories in B<findRE> (default: base 
filenames only).

for the sake of intuition this options automatically sets .*? as prefix and 
(?=[^\/]*\z) as suffix of B<findRE>.

=item B<--recursive>, B<-r>

search subdirectories recursively

=item B<--test>, B<-t>

don't change anything, just print possible changes to screen

=item B<--tr>, B<-y>

use charwise replacement tr/findRE/replaceRE/ instead of s/findRE/replaceRE/.

see perl manual for more information.

=over 8

=item B<--tr_c>, B<--cmodifier>

use c-modifier (only if B<--tr> is used), i.e., complement B<findRE>.

=item B<--tr_d>, B<--dmodifier>

use d-modifier (only if B<--tr> is used), i.e., delete found but unreplaced characters.

=item B<--tr_s>, B<--smodifier>

use s-modifier (only if B<--tr> is used), i.e., squash duplicate replaced characters.

=back

=item B<--utf8>, B<-u>

enable unicode support for input, output, and renaming

=item B<--predictive>=I<bool>, B<-p> I<bool>

look for possible overwriting first before renaming (or don't)...

I<bool> = 0: start renaming, but skip those files that would lead to overwriting another file that shouldn't be overwritten (depends on B<--force>).

I<bool> = 1 (default): don't even start renaming (of any file), if ther is at least one file that would be and shouldn't be overwritten (depends on B<--force>).

=item B<--force>, B<-f>

same as B<--force>=I<1>

=item B<--force>=I<int>, B<-f> I<int>

grade of forcing renaming

I<int> = 0 (default): don't overwrite any files

I<int> = 1: overwrite existing (but not already renamed) files

I<int> = 2: overwrite even renamed files

=item B<--emodifier>, B<-e>

set e-modifier in RE, i.e., 

 s/findRE/replaceRE/e

maybe you should consider using B<--no-auto> if you use slashes in B<replaceRE>.

don't combine this with parameter B<--tr>.

=item B<--global>, B<--gmodifier>, B<-g>

set g-modifier, i.e., rename as many times as possible, i.e., 

 s/findRE/replaceRE/g

don't combine this with parameter B<--tr>.

=item B<--ignorecase>, B<--imodifier>, B<-i>

set i-modifier, i.e., ignore case in B<findRE>, i.e., 

 s/findRE/replaceRE/i
 
don't combine this with parameter B<--tr>.

=item B<--version>, B<-V>

prints version and exits.

=item B<--help>, B<-h>, B<-?>

prints a brief help message and exits.

=item B<--man>

prints the manual page and exits.

=item B<--verbose>=I<number>, B<-v> I<number>

set grade of verbosity to I<number>. if I<number>==0 then no output
will be given, except hard errors. the higher I<number> is, the more 
output will be printed. default: I<number> = 1.

=item B<--silent, --quiet, -q>

same as B<--verbose=0>.

=item B<--very-verbose, -vv>

same as B<--verbose=3>. you may use B<-vvv> for B<--verbose=4> a.s.o.

=item B<--verbose, -v>

same as B<--verbose=2>.

=back

=head1 LICENCE

BSD-2-Clause

Copyright (c) 2014-2017, seth
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

originally written by seth (see https://github.com/wp-seth/ren_ext)

=cut
