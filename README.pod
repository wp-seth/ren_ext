=head1 NAME

ren_ext ("rename extended") renames (recursively) files and directories using 
regexps.

=head1 DESCRIPTION

this program lets you rename files or directories by using regular expressions. 

it includes a check, whether a target filename already exists or whether several 
target filenames are same, and prints a warning in such cases.

=head1 SYNOPSIS

ren_ext findRE replaceRE [options]
or
ren_ext [options] findRE replaceRE

  findRE                 files to rename given by a regexp
  replaceRE              how to rename, i.e., s/findRE/replaceRE/ in perl syntax
  -c, --capitalize       Capitalize Every Word
  -d, --directories      rename files and directories (default: files only)
  -D, --Directories      rename directories only (default: files only)
  -m, --mtime            use $y, $mon, $d, $h, $min, $s in replaceRE to insert
                          modification time
      --path             while searching use full paths of files in findRE
                          (default: base filenames only)
                          for the sake of intuition this options automatically 
                          sets .*? as prefix and (?=[^\/]*\z) as suffix of
                          findRE
      --no-auto          disables automatisms, i.e., 
                          1. automatically generated prefixes and suffixes
                             in findRE, when using --path, and
                          2. escaping of unescaped slashes in findRE, filesRE,
                             and replaceRE by backslashes
  -r, --recursive        for searching subdirectories recursively
  -t, --test             don't change anything, just print possible changes to
                          screen
  -u, --utf8             enable unicode support for input, output, and renaming
  -y  --tr               use tr/findRE/replaceRE/ instead of s/findRE/replaceRE/
  -F  --filesRE=s        restrict replacements to files given by regexp string s 
                          (default s=".", i.e., all files)

force overwriting:

  -p, --predictive=x     (don't) look for possible overwriting first ...
                          x=0: start renaming, but skip those files that would 
                               overwrite other files that shouldn't be 
                               overwritten (depends on --force).
                          x=1: don't even start renaming of any file, if one
                               file would be overwritten that shouldn't be 
                               overwritten (depends on --force). (default)
  -f, --force            same as --force=1
  -f, --force=x          grade of forcing renaming
                          x=0: don't overwrite any files (default)
                          x=1: overwrite existing (but not already renamed)
                               files
                          x=2: overwrite even renamed files

regexp-modifiers:

  -e, --emodifier        set e-modifier in RE, i.e., s/findRE/replaceRE/e
                          (maybe you should consider using --no-auto if you
                           use slashes in replaceRE)
                          (don't combine this with parameter --tr)
  -g, --global           set g-modifier, i.e., rename as many times as possible,
                          i.e., s/findRE/replaceRE/g
                          (don't combine this with parameter --tr)
  -i, --ignorecase       set i-modifier, i.e., ignore case in findRE, i.e., 
                          s/findRE/replaceRE/i
                          (don't combine this with parameter --tr)
      --tr_c             use c-modifier (only if --tr is used), i.e., 
                         complement findRE.
      --tr_d             use d-modifier (only if --tr is used), i.e.,
                          delete found but unreplaced characters.
      --tr_s             use s-modifier (only if --tr is used), i.e.,
                          squash duplicate replaced characters.
meta:

      --examples         show some examples of using this tool
  -V, --version          display version and exit.
  -h, --help             display brief help
      --man              display long help (man page)
  -q, --silent           same as --verbose=0
  -v, --verbose          same as --verbose=2
  -vv,--very-verbose     same as --verbose=3
  -v, --verbose=x        grade of verbosity
                          x=0: no output
                          x=1: default output
                          x=2: much output

some examples:

  ren_ext ASD asd
    replaces _first_ occurrence of 'ASD' by 'asd' in all files, e.g.
    fooASDASD.txt -> fooasdASD.txt (use -g for replacing all occurrences)
  
  ren_ext --examples
    shows more examples

=head1 EXAMPLES

ren_ext

  displays help

ren_ext 'ASD' 'sdf'

  replaces _first_ occurrence of "ASD" by "sdf" in all files, e.g.
  fooASDASD.txt -> foosdfASD.txt

ren_ext 'ASD' 'sdf' -g

  replaces all occurrence of 'ASD' by 'sdf' in all files, e.g.
  fooASDASD.txt -> foosdfsdf.txt

ren_ext '(.)' '\u$1'

  sets _first_ character to upper case.

ren_ext '(.)' '\l$1' -g

  sets all characters to lower case.

ren_ext '[A-Z]' '[a-z]' -y

  sets all latin characters to lower case.

ren_ext '(\p{Cyrillic}+)' '\U$1' -drug

  uppercase all cyrillic letters of files and directories in this 
  directory and all subdirectories.

ren_ext '.*cd(\d+)/([^/]+)$' '$1$2' --path -r

  uses full path, i.e., renames ...cd01/title.ogg to
  ...cd01/01title.ogg and so on (no files will be moved to another
  directory).

ren_ext '(/d)(/d)' '$2$1' -gr

  exchanges digits of numbers in all filenames recursively.

ren_ext '(error_log\.)\d+(\.gz)' '$1$y-$mon-$d$2' --mtime

  e.g. errog_log.10.gz -> error_log.2007-07-07.gz

ren_ext -r -- -foo -bar

  this will replace '-foo' by '-bar' recursively.

ren_ext 'foo(\d\d)' '"bar".($1+42)' -ert

  prints the result of replacing e.g. 'foo10' by 'bar52' recursively,
  but doesn't really change filenames.

ren_ext 'xy' 'yx' --tr -F 'foo_x=\d+_y=\d+'

  use tr/xy/yx/ on all files that match /foo_x=\d+_y=\d+/, i.e., 
  switch the letters 'x' and 'y' in all of those files.

ren_ext -e 'segment\K([0-9]+)(?=_)' 'sprintf("%03d", $1)'

  add leading zeros on numbers with <3 digits, e.g., 
  change parts like 'segment{number}_' to 'segment{number_with_leading_zero}_'.

note that in microsoft windows you have to use double quotes instead of single 
quotes.

=head1 OPTIONS

=over 8

=item B<--auto>, B<--no-auto>

B<--auto> enables automatisms, i.e., 

1. automatically generated prefixes and suffixes in B<findRE>, when using B<--path>, and

2. escaping of unescaped slashes in B<findRE>, B<--filesRE>, and B<replaceRE> by backslashes.

B<--no-auto> disables those automatisms.

=item B<--capitalize>, B<-c>

Capitalize Every Word In Filename

=item B<--directories>, B<-d>

rename files and directories (default: files only)

=item B<--Directories>, B<-D>

rename directories only (default: files only)

=item B<--filesRE>=I<string>, B<-F> I<string>

restrict replacements to files given by regexp I<string> (default ".", i.e., all files)

=item B<--mtime>, B<-m>

use $y, $mon, $d, $h, $min, $s in B<replaceRE> to insert file modification time

=item B<--path>

while searching use full paths of files/directories in B<findRE> (default: base 
filenames only).

for the sake of intuition this options automatically sets .*? as prefix and 
(?=[^\/]*\z) as suffix of B<findRE>.

=item B<--recursive>, B<-r>

search subdirectories recursively

=item B<--test>, B<-t>

don't change anything, just print possible changes to screen

=item B<--tr>, B<-y>

use charwise replacement tr/findRE/replaceRE/ instead of s/findRE/replaceRE/.

see perl manual for more information.

=over 8

=item B<--tr_c>, B<--cmodifier>

use c-modifier (only if B<--tr> is used), i.e., complement B<findRE>.

=item B<--tr_d>, B<--dmodifier>

use d-modifier (only if B<--tr> is used), i.e., delete found but unreplaced characters.

=item B<--tr_s>, B<--smodifier>

use s-modifier (only if B<--tr> is used), i.e., squash duplicate replaced characters.

=back

=item B<--utf8>, B<-u>

enable unicode support for input, output, and renaming

=item B<--predictive>=I<bool>, B<-p> I<bool>

look for possible overwriting first before renaming (or don't)...

I<bool> = 0: start renaming, but skip those files that would lead to overwriting another file that shouldn't be overwritten (depends on B<--force>).

I<bool> = 1 (default): don't even start renaming (of any file), if ther is at least one file that would be and shouldn't be overwritten (depends on B<--force>).

=item B<--force>, B<-f>

same as B<--force>=I<1>

=item B<--force>=I<int>, B<-f> I<int>

grade of forcing renaming

I<int> = 0 (default): don't overwrite any files

I<int> = 1: overwrite existing (but not already renamed) files

I<int> = 2: overwrite even renamed files

=item B<--emodifier>, B<-e>

set e-modifier in RE, i.e., 

 s/findRE/replaceRE/e

maybe you should consider using B<--no-auto> if you use slashes in B<replaceRE>.

don't combine this with parameter B<--tr>.

=item B<--global>, B<--gmodifier>, B<-g>

set g-modifier, i.e., rename as many times as possible, i.e., 

 s/findRE/replaceRE/g

don't combine this with parameter B<--tr>.

=item B<--ignorecase>, B<--imodifier>, B<-i>

set i-modifier, i.e., ignore case in B<findRE>, i.e., 

 s/findRE/replaceRE/i
 
don't combine this with parameter B<--tr>.

=item B<--version>, B<-V>

prints version and exits.

=item B<--help>, B<-h>, B<-?>

prints a brief help message and exits.

=item B<--man>

prints the manual page and exits.

=item B<--verbose>=I<number>, B<-v> I<number>

set grade of verbosity to I<number>. if I<number>==0 then no output
will be given, except hard errors. the higher I<number> is, the more 
output will be printed. default: I<number> = 1.

=item B<--silent, --quiet, -q>

same as B<--verbose=0>.

=item B<--very-verbose, -vv>

same as B<--verbose=3>. you may use B<-vvv> for B<--verbose=4> a.s.o.

=item B<--verbose, -v>

same as B<--verbose=2>.

=back

=head1 LICENCE

BSD-2-Clause

Copyright (c) 2014-2017, seth
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

originally written by seth (see https://github.com/wp-seth/ren_ext)

